"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildDepGraphNpmLockV2 = exports.parseNpmLockV2Project = exports.extractPkgsFromNpmLockV2 = void 0;
const extract_npm_lock_v2_pkgs_1 = require("./extract-npm-lock-v2-pkgs");
Object.defineProperty(exports, "extractPkgsFromNpmLockV2", { enumerable: true, get: function () { return extract_npm_lock_v2_pkgs_1.extractPkgsFromNpmLockV2; } });
const dep_graph_1 = require("@snyk/dep-graph");
const util_1 = require("../util");
const errors_1 = require("../../errors");
const parsers_1 = require("../../parsers");
const micromatch = require("micromatch");
const pathUtil = require("path");
const parseNpmLockV2Project = (pkgJsonContent, pkgLockContent, options) => {
    const { includeDevDeps, strictOutOfSync, includeOptionalDeps } = options;
    const pkgJson = (0, util_1.parsePkgJson)(pkgJsonContent);
    const pkgs = (0, extract_npm_lock_v2_pkgs_1.extractPkgsFromNpmLockV2)(pkgLockContent);
    const depgraph = (0, exports.buildDepGraphNpmLockV2)(pkgs, pkgJson, {
        includeDevDeps,
        includeOptionalDeps,
        strictOutOfSync,
    });
    return depgraph;
};
exports.parseNpmLockV2Project = parseNpmLockV2Project;
const buildDepGraphNpmLockV2 = (npmLockPkgs, pkgJson, options) => {
    const { includeDevDeps, strictOutOfSync, includeOptionalDeps } = options;
    const depGraphBuilder = new dep_graph_1.DepGraphBuilder({ name: 'npm' }, { name: pkgJson.name, version: pkgJson.version });
    const topLevelDeps = (0, util_1.getTopLevelDeps)(pkgJson, {
        includeDevDeps,
        includeOptionalDeps,
        includePeerDeps: true,
    });
    const rootNode = {
        id: 'root-node',
        name: pkgJson.name,
        version: pkgJson.version,
        dependencies: topLevelDeps,
        isDev: false,
        inBundle: false,
        key: '',
    };
    const pkgKeysByName = Object.keys(npmLockPkgs).reduce((acc, key) => {
        const name = key.replace(/.*node_modules\//, '');
        if (!name) {
            return acc;
        }
        if (!acc.has(name)) {
            acc.set(name, []);
        }
        acc.get(name).push(key);
        return acc;
    }, new Map());
    const visitedMap = new Set();
    dfsVisit(depGraphBuilder, rootNode, visitedMap, npmLockPkgs, strictOutOfSync, includeOptionalDeps, [], pkgKeysByName);
    return depGraphBuilder.build();
};
exports.buildDepGraphNpmLockV2 = buildDepGraphNpmLockV2;
const dfsVisit = (depGraphBuilder, node, visitedMap, npmLockPkgs, strictOutOfSync, includeOptionalDeps, ancestry, pkgKeysByName) => {
    visitedMap.add(node.id);
    for (const [name, depInfo] of Object.entries(node.dependencies || {})) {
        const childNode = getChildNode(name, depInfo, npmLockPkgs, strictOutOfSync, includeOptionalDeps, [
            ...ancestry,
            {
                name: node.name,
                key: node.key || '',
                inBundle: node.inBundle || false,
            },
        ], pkgKeysByName);
        if (!visitedMap.has(childNode.id)) {
            (0, util_1.addPkgNodeToGraph)(depGraphBuilder, childNode, {});
            dfsVisit(depGraphBuilder, childNode, visitedMap, npmLockPkgs, strictOutOfSync, includeOptionalDeps, [
                ...ancestry,
                {
                    name: node.name,
                    key: node.key,
                    inBundle: node.inBundle || false,
                },
            ], pkgKeysByName);
        }
        depGraphBuilder.connectDep(node.id, childNode.id);
    }
};
const getChildNode = (name, depInfo, pkgs, strictOutOfSync, includeOptionalDeps, ancestry, pkgKeysByName) => {
    let childNodeKey = getChildNodeKey(name, ancestry, pkgs, pkgKeysByName); //
    if (!childNodeKey) {
        if (strictOutOfSync) {
            throw new errors_1.OutOfSyncError(`${name}@${depInfo.version}`, parsers_1.LockfileType.npm);
        }
        else {
            return {
                id: `${name}@${depInfo.version}`,
                name: name,
                version: depInfo.version,
                dependencies: {},
                isDev: depInfo.isDev,
                missingLockFileEntry: true,
                key: '',
            };
        }
    }
    let depData = pkgs[childNodeKey];
    const resolvedToWorkspace = () => {
        const workspacesDeclaration = pkgs['']['workspaces'] || [];
        const resolvedPath = depData.resolved || '';
        const fixedResolvedPath = resolvedPath.replace(/\\/g, '/');
        const normalizedWorkspacesDefn = workspacesDeclaration.map((p) => {
            return pathUtil.normalize(p).replace(/\\/g, '/');
        });
        return micromatch.isMatch(fixedResolvedPath, normalizedWorkspacesDefn);
    };
    // Check for workspaces
    if (depData['link'] && resolvedToWorkspace()) {
        childNodeKey = depData.resolved;
        depData = pkgs[depData.resolved];
    }
    const dependencies = (0, util_1.getGraphDependencies)(depData.dependencies || {}, depInfo.isDev);
    const optionalDependencies = includeOptionalDeps
        ? (0, util_1.getGraphDependencies)(depData.optionalDependencies || {}, depInfo.isDev)
        : {};
    return {
        id: `${name}@${depData.version}`,
        name: name,
        version: depData.version,
        dependencies: Object.assign(Object.assign({}, dependencies), optionalDependencies),
        isDev: depInfo.isDev,
        inBundle: depData.inBundle,
        key: childNodeKey,
    };
};
const getChildNodeKey = (name, ancestry, pkgs, pkgKeysByName) => {
    const candidateKeys = pkgKeysByName.get(name);
    // Lockfile missing entry
    if (!candidateKeys) {
        return undefined;
    }
    // Only one candidate then just take it
    if (candidateKeys.length === 1) {
        return candidateKeys[0];
    }
    // If we are a bundled dep we have to choose candidate carefully
    if (ancestry.length && ancestry[ancestry.length - 1].inBundle) {
        const bundleRootIdx = ancestry.findIndex((el) => el.inBundle === true) - 1;
        const ancestryFromBundleId = [
            ...ancestry.slice(bundleRootIdx).map((el) => el.name),
            name,
        ];
        const candidateAncestries = candidateKeys.map((el) => el.replace('node_modules/', '').split('/node_modules/'));
        const filteredCandidates = candidateKeys.filter((candidate, idx) => {
            return candidateAncestries[idx].every((pkg) => {
                return ancestryFromBundleId.includes(pkg);
            });
        });
        if (filteredCandidates.length === 1) {
            return filteredCandidates[0];
        }
        const sortedKeys = filteredCandidates.sort((a, b) => b.split('/node_modules/').length - a.split('/node_modules/').length);
        const longestPathLength = sortedKeys[0].split('/node_modules/').length;
        const onlyLongestKeys = sortedKeys.filter((key) => key.split('/node_modules/').length === longestPathLength);
        if (onlyLongestKeys.length === 1) {
            return onlyLongestKeys[0];
        }
        // Here we go through parents keys to see if any are the branch point
        // we could have done this sooner but the above work as good short circuits
        let keysFilteredByParentKey = onlyLongestKeys;
        const reversedAncestry = ancestry.reverse();
        for (let parentIndex = 0; parentIndex < reversedAncestry.length; parentIndex++) {
            const parentKey = reversedAncestry[parentIndex].key;
            const possibleFilteredKeys = keysFilteredByParentKey.filter((key) => key.includes(parentKey));
            if (possibleFilteredKeys.length === 1) {
                return possibleFilteredKeys[0];
            }
            if (possibleFilteredKeys.length === 0) {
                continue;
            }
            keysFilteredByParentKey = possibleFilteredKeys;
        }
    }
    // If not in bundle then we can just see if it is scoped by parent
    // and then just look directly for it
    if (ancestry.length === 1) {
        return `node_modules/${name}`;
    }
    const parentName = ancestry[ancestry.length - 1].name;
    return pkgs[`node_modules/${parentName}/node_modules/${name}`]
        ? `node_modules/${parentName}/node_modules/${name}`
        : `node_modules/${name}`;
};
//# sourceMappingURL=index.js.map